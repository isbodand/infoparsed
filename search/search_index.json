{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"InfoParse InfoParse is a CLI parameter parser influenced by Perl's core Getopt::Long package. The following two snippets are more or less equivalent: Perl using Getopt::Long use Getopt::Long; # Variables my $var1; my $var2; # Parsing GetOptions( 'b|bool' = \\$var1, 's|string=s'= \\$var2 ); # Output print 'Var1: ' . ($var1 ? 'True' : 'False') . \\n ; print qq/Var2: $var2 \\n/ C++ using InfoParse #include iostream #include string #include infoparse/OptionsParser int main(int argc, char** argv) { // Variables bool var1; std::string var2; // Parsing info::parse::OptionsParser parser; parser.addOptions() ( b|bool , var1) ( s|string , var2) ; parser.parse(argc, argv); // Output std::cout std::boolaplha Var1: var1 \\n Var2: \\ var2 ' ' std::endl; return 0; }","title":"Home"},{"location":"#infoparse","text":"InfoParse is a CLI parameter parser influenced by Perl's core Getopt::Long package. The following two snippets are more or less equivalent: Perl using Getopt::Long use Getopt::Long; # Variables my $var1; my $var2; # Parsing GetOptions( 'b|bool' = \\$var1, 's|string=s'= \\$var2 ); # Output print 'Var1: ' . ($var1 ? 'True' : 'False') . \\n ; print qq/Var2: $var2 \\n/ C++ using InfoParse #include iostream #include string #include infoparse/OptionsParser int main(int argc, char** argv) { // Variables bool var1; std::string var2; // Parsing info::parse::OptionsParser parser; parser.addOptions() ( b|bool , var1) ( s|string , var2) ; parser.parse(argc, argv); // Output std::cout std::boolaplha Var1: var1 \\n Var2: \\ var2 ' ' std::endl; return 0; }","title":"InfoParse"},{"location":"api/","text":"API The API is pretty easy to handle, this combined with my madness complicated the implementation, but never mind that. Only one class is present in the info::parse namespace, others are info::parse::Internals namespace which, you'd never guess it, is for internal use. Include The library - if installed correctly and not butchered like how I usually install stuff - has its directory called infoparse , where all headers reside. Therefrom do you need to include Construction This only class is OptionsParser . As of 1.4.0 , this class is default constructed, so you can easily just pop it wherever you want: [Note: For the followings IP is an alias to namespace info::parse .] IP::OptionsParser parser; And with that your parser is constructed, but not much happened, not even internally. Options To actually get something going we need to input the options which are to be parsed. This can be done in the two following ways, and a third one is to arrive in a following update soon(tm). The first and original way is to add the options by hand. This is a bit tedious but compared to the migraine of writing JS it is nothing. Single int i = 0; // Be good and initialize your variables parser.addOption( amazingly-great-option-name , i); bool silent = false; bool chain = false; parser.addOption( silent|quiet|s|q , silent) .addOption( calls-can-be-chained , wget); This method adds options one-by-one as the above example presents. addOption takes a OptionString (which is implicitly constructed from std::string s or string literals, mind you) which parses the input string into the names of the parameters, by splitting the string on the pipes '|' . Also note that addOption returns a reference to the IP::OptionsParser which you called it from, so as shown on the second and third call they can be chain called. [Note: Up to and including 1.4.x the return value was a pointer to the parser object.] Multiple int i = 0; bool silent = false; bool chain = false; parser.addOptions() ( easy|fast , i) ( sleek , silent) ( boost-like , wget) ; As found in some Boost libraries (such as Boost.ProgramOptions) this method of adding multiple options is a new and shiny feature since 1.4.0 . Their behaviour is exactly the same as if it were addOption called n times separately, and thus all documentation is presented there . Functions However mighty variables are, they are boring. Having functions as possible output variables definitely is not. Since the glorious release of version 1.5.0 , using any kind of callable is a great way to specify callbacks to the parser system. Works with function pointers, function objects and even lambdas. While values specify the type of the program parameter by their own type, lambdas, and function pointers do so with their parameter type. Callables may have some type T as their parameter iff T implements the streaming operator , or void : If their type is T , they will be called with an argument of type T , parsed from the program arguments; if their type is void they will be called without any value being passed to them, as if the boolean value were to be encoded in the fact that whether or not they are called. See this example of using function callbacks. #include iostream #include cstdlib #include infoparse/OptionsParser.hpp [[noreturn]] void help(); [[noreturn]] void version(); int main(int argc, char** argv) { // K R braces All the way // Setup info::parse::OptionsParser parser; parser.addOptions() ( help|h|? , help) ( version|v , version) ( lambda|l , [ ](const std::string str) { std::cout str std::endl; }) ; // Parsing auto rem = parser.parse(argc, argv); // Whatever std::cout Parameters: rem std::endl; return 0; } void help() { std::cout Example v1\\n Usage: xmpl [options]\\n -h --help -?\\tShow this message and exit\\n -v --version\\tShow version and exit std::endl; std::exit(0); } void version() { std::cout Example v1 std::endl; std::exit(0); } Failure and success conditions Depending on the configuration and on the function's return value, a function may be deemed to have succeeded or to have failed by the library upon calling the callback-function. The failure and success conditions are as of the followings. 1) A void function is always successful. 2) A function returning a pointer is successful if the returned pointer is not nullptr . [Note: See configs for returned pointers that should be deleted.] 3) If the returned value is convertible to int the following expression determines success: ((int) f(args...)) == 0 where f is the callback function and args... are the parameters. 4) A function whose return value is convertible to bool , that equals whether the function failed or not. 5) Any other case the function is hoped to have succeeded.","title":"API"},{"location":"api/#api","text":"The API is pretty easy to handle, this combined with my madness complicated the implementation, but never mind that. Only one class is present in the info::parse namespace, others are info::parse::Internals namespace which, you'd never guess it, is for internal use.","title":"API"},{"location":"api/#include","text":"The library - if installed correctly and not butchered like how I usually install stuff - has its directory called infoparse , where all headers reside. Therefrom do you need to include","title":"Include"},{"location":"api/#construction","text":"This only class is OptionsParser . As of 1.4.0 , this class is default constructed, so you can easily just pop it wherever you want: [Note: For the followings IP is an alias to namespace info::parse .] IP::OptionsParser parser; And with that your parser is constructed, but not much happened, not even internally.","title":"Construction"},{"location":"api/#options","text":"To actually get something going we need to input the options which are to be parsed. This can be done in the two following ways, and a third one is to arrive in a following update soon(tm). The first and original way is to add the options by hand. This is a bit tedious but compared to the migraine of writing JS it is nothing.","title":"Options"},{"location":"api/#single","text":"int i = 0; // Be good and initialize your variables parser.addOption( amazingly-great-option-name , i); bool silent = false; bool chain = false; parser.addOption( silent|quiet|s|q , silent) .addOption( calls-can-be-chained , wget); This method adds options one-by-one as the above example presents. addOption takes a OptionString (which is implicitly constructed from std::string s or string literals, mind you) which parses the input string into the names of the parameters, by splitting the string on the pipes '|' . Also note that addOption returns a reference to the IP::OptionsParser which you called it from, so as shown on the second and third call they can be chain called. [Note: Up to and including 1.4.x the return value was a pointer to the parser object.]","title":"Single"},{"location":"api/#multiple","text":"int i = 0; bool silent = false; bool chain = false; parser.addOptions() ( easy|fast , i) ( sleek , silent) ( boost-like , wget) ; As found in some Boost libraries (such as Boost.ProgramOptions) this method of adding multiple options is a new and shiny feature since 1.4.0 . Their behaviour is exactly the same as if it were addOption called n times separately, and thus all documentation is presented there .","title":"Multiple"},{"location":"api/#functions","text":"However mighty variables are, they are boring. Having functions as possible output variables definitely is not. Since the glorious release of version 1.5.0 , using any kind of callable is a great way to specify callbacks to the parser system. Works with function pointers, function objects and even lambdas. While values specify the type of the program parameter by their own type, lambdas, and function pointers do so with their parameter type. Callables may have some type T as their parameter iff T implements the streaming operator , or void : If their type is T , they will be called with an argument of type T , parsed from the program arguments; if their type is void they will be called without any value being passed to them, as if the boolean value were to be encoded in the fact that whether or not they are called. See this example of using function callbacks. #include iostream #include cstdlib #include infoparse/OptionsParser.hpp [[noreturn]] void help(); [[noreturn]] void version(); int main(int argc, char** argv) { // K R braces All the way // Setup info::parse::OptionsParser parser; parser.addOptions() ( help|h|? , help) ( version|v , version) ( lambda|l , [ ](const std::string str) { std::cout str std::endl; }) ; // Parsing auto rem = parser.parse(argc, argv); // Whatever std::cout Parameters: rem std::endl; return 0; } void help() { std::cout Example v1\\n Usage: xmpl [options]\\n -h --help -?\\tShow this message and exit\\n -v --version\\tShow version and exit std::endl; std::exit(0); } void version() { std::cout Example v1 std::endl; std::exit(0); }","title":"Functions"},{"location":"api/#failure-and-success-conditions","text":"Depending on the configuration and on the function's return value, a function may be deemed to have succeeded or to have failed by the library upon calling the callback-function. The failure and success conditions are as of the followings. 1) A void function is always successful. 2) A function returning a pointer is successful if the returned pointer is not nullptr . [Note: See configs for returned pointers that should be deleted.] 3) If the returned value is convertible to int the following expression determines success: ((int) f(args...)) == 0 where f is the callback function and args... are the parameters. 4) A function whose return value is convertible to bool , that equals whether the function failed or not. 5) Any other case the function is hoped to have succeeded.","title":"Failure and success conditions"},{"location":"build/","text":"Prerequisites The following are required for the ability to build infoparse: A C++17 compliant C++ compiler [Note: According to their docs this means GCC 7+, clang 3.9+ ] [Note: Currently I cannot guarantee that MSVC works. On my system it shits itself quite badly.] [Note: While GCC 7+ and clang 3.9+ can compile the library, the tests require GCC 9+ or clang 5+.] CMake 3.10+ A make implementation is most likely necessary as well. Or maybe not if you use ninja , I don't know, but normally it is. Downloading Sources Our hopefully painless journey of building infoparse starts with loading the required supplies aka downloading the source. The followings describe the most common ways this can be done. git The sources are available on github, so you can pull them using git : git clone https://github.com/isbodand/infoparse.git Tarball If for whatever reason using git is not possible you can resort to the good ol' curl and tar combo. curl -Ls https://github.com/isbodand/infoparse/archive/master.tar.gz | tar xz This will create a infoparse-master directory with the sources for info::parse. [Note: Checksums are not provided by GitHub so don't need to be angry at me for not checking them. If you don't want to download things without a checksum use the git method.] zip If you happen to be stuck on a Windows PC without the required tooling to get yourself curl and/or tar . You can try any of the following options to get yourself info::parse: PowerShell PS Invoke-Webrequest https://github.com/isbodand/infoparse/archive/master.zip -OutFile infoparse.zip PS Expand-Archive infoparse.zip cmd If you are running and inferior version of Windows and don't have access to PS or you broke it at some point in time: bitsadmin /transfer info::parseDownload /priority high https://github.com/isbodand/infoparse/archive/master.zip %home%/Downloads/infoparse.zip If using cmd you have no build-in way of unzipping files, so figuring out this is left as an exercise to the reader, possible procedures range from 7z to abusing jar . Configuring CMake After you got yourself the source, you need to tell cmake to configure it. This is done it 2 steps: 1) Creating a build directory mkdir build cd build 2) Calling CMake cmake .. Calling the build tool The previous command created the required files for the build tool to build infoparse, one just needs to call it. TIMTOWDI is in effect; here are your options: CMake CMake is able to call the required build tool for the configuration it generated. To do so just call: cmake --build . Calling the tool itself This command varies by platform, here are a few, however if you are not sure which tool to call, just call through CMake as described above. make for *nix people msbuild info::parse.sln for MSVC mingw32-make for MinGW","title":"Build it yourself"},{"location":"build/#prerequisites","text":"The following are required for the ability to build infoparse: A C++17 compliant C++ compiler [Note: According to their docs this means GCC 7+, clang 3.9+ ] [Note: Currently I cannot guarantee that MSVC works. On my system it shits itself quite badly.] [Note: While GCC 7+ and clang 3.9+ can compile the library, the tests require GCC 9+ or clang 5+.] CMake 3.10+ A make implementation is most likely necessary as well. Or maybe not if you use ninja , I don't know, but normally it is.","title":"Prerequisites"},{"location":"build/#downloading-sources","text":"Our hopefully painless journey of building infoparse starts with loading the required supplies aka downloading the source. The followings describe the most common ways this can be done.","title":"Downloading Sources"},{"location":"build/#git","text":"The sources are available on github, so you can pull them using git : git clone https://github.com/isbodand/infoparse.git","title":"git"},{"location":"build/#tarball","text":"If for whatever reason using git is not possible you can resort to the good ol' curl and tar combo. curl -Ls https://github.com/isbodand/infoparse/archive/master.tar.gz | tar xz This will create a infoparse-master directory with the sources for info::parse. [Note: Checksums are not provided by GitHub so don't need to be angry at me for not checking them. If you don't want to download things without a checksum use the git method.]","title":"Tarball"},{"location":"build/#zip","text":"If you happen to be stuck on a Windows PC without the required tooling to get yourself curl and/or tar . You can try any of the following options to get yourself info::parse:","title":"zip"},{"location":"build/#powershell","text":"PS Invoke-Webrequest https://github.com/isbodand/infoparse/archive/master.zip -OutFile infoparse.zip PS Expand-Archive infoparse.zip","title":"PowerShell"},{"location":"build/#cmd","text":"If you are running and inferior version of Windows and don't have access to PS or you broke it at some point in time: bitsadmin /transfer info::parseDownload /priority high https://github.com/isbodand/infoparse/archive/master.zip %home%/Downloads/infoparse.zip If using cmd you have no build-in way of unzipping files, so figuring out this is left as an exercise to the reader, possible procedures range from 7z to abusing jar .","title":"cmd"},{"location":"build/#configuring-cmake","text":"After you got yourself the source, you need to tell cmake to configure it. This is done it 2 steps: 1) Creating a build directory mkdir build cd build 2) Calling CMake cmake ..","title":"Configuring CMake"},{"location":"build/#calling-the-build-tool","text":"The previous command created the required files for the build tool to build infoparse, one just needs to call it. TIMTOWDI is in effect; here are your options:","title":"Calling the build tool"},{"location":"build/#cmake","text":"CMake is able to call the required build tool for the configuration it generated. To do so just call: cmake --build .","title":"CMake"},{"location":"build/#calling-the-tool-itself","text":"This command varies by platform, here are a few, however if you are not sure which tool to call, just call through CMake as described above. make for *nix people msbuild info::parse.sln for MSVC mingw32-make for MinGW","title":"Calling the tool itself"},{"location":"conf/","text":"Configurations While InfoParse is not the most configurable of libraries; it still offers some ability to be configured. Configuration is done by setting or defining specific macros before including any library header. The macros are listed in the followings, by describing the library's behavior in both cases whether or not the macro is defined. Parameters define the value it is supposed to be set. \"Parameters: none \" means only defined-ness(?) is checked. INFO_RETRY_FAILED_CALLBACK_FUNCTION Parameters: none If defined the library once retries running a callback function, in case it is deemed to have failed. Failure conditions are described here . INFO_PARSER_FAIL_BAD_FUNCTION_SILENTLY Parameters: none If the callback takes more that 2 parameters the library upon realizing this when trying to call the function, throws a bad_function_callback exception. Note this is hardly required as OptionsParser static asserts less than or equal to 2 on it's input of addOption, so only needed if instantiating Option_ manually, which you shouldn't be doing in the first place, so bear the consequences. INFO_DELETE_RETURN_VALUE_OF_CALLBACK Parameters: none If the callback function returns a pointer which is supposed to be deleted, for some ungodly reason, with this option the library will call delete ptr , where ptr is the value returned by the callback. Note that this is then called for every returned pointer. INFO_USE_BUILD_TIME_IN_VERSION Parameters: 1 or 0 whether yes or no; default is 1 Decides whether build time is to be shown in the version number of the library.","title":"Config"},{"location":"conf/#configurations","text":"While InfoParse is not the most configurable of libraries; it still offers some ability to be configured. Configuration is done by setting or defining specific macros before including any library header. The macros are listed in the followings, by describing the library's behavior in both cases whether or not the macro is defined. Parameters define the value it is supposed to be set. \"Parameters: none \" means only defined-ness(?) is checked.","title":"Configurations"},{"location":"conf/#info_retry_failed_callback_function","text":"Parameters: none If defined the library once retries running a callback function, in case it is deemed to have failed. Failure conditions are described here .","title":"INFO_RETRY_FAILED_CALLBACK_FUNCTION"},{"location":"conf/#info_parser_fail_bad_function_silently","text":"Parameters: none If the callback takes more that 2 parameters the library upon realizing this when trying to call the function, throws a bad_function_callback exception. Note this is hardly required as OptionsParser static asserts less than or equal to 2 on it's input of addOption, so only needed if instantiating Option_ manually, which you shouldn't be doing in the first place, so bear the consequences.","title":"INFO_PARSER_FAIL_BAD_FUNCTION_SILENTLY"},{"location":"conf/#info_delete_return_value_of_callback","text":"Parameters: none If the callback function returns a pointer which is supposed to be deleted, for some ungodly reason, with this option the library will call delete ptr , where ptr is the value returned by the callback. Note that this is then called for every returned pointer.","title":"INFO_DELETE_RETURN_VALUE_OF_CALLBACK"},{"location":"conf/#info_use_build_time_in_version","text":"Parameters: 1 or 0 whether yes or no; default is 1 Decides whether build time is to be shown in the version number of the library.","title":"INFO_USE_BUILD_TIME_IN_VERSION"},{"location":"convention/","text":"Conventions The info::parse source uses some standard-ish conventions. These are not that intrusive after getting used them. The followings describe what these are and what they are doing, as some are a bit cryptic on first sight for those not necessarily well versed in the C++ language's abusability. Naming Variable names are camelCase Normal macros are SCREAMING_SNAKE_CASE Macros that are applied to something like a function are _lowercase Class names are PascalCase Classes that behave like interfaces are PascalCase and are an adjective, like the Java convention for interfaces. Member variables are _camelCase , while prefering single-word names, if possible, of course. Accessor member functions are the name of the member variable without the leading underscore Accessor member functions are the name of the member variable without the leading underscore, while taking a parameter of the approriate type static and/or non-member functions are PascalCase Namespace of the project is info::parse , implementation details inside the detail subnamespace. Macros The following preprocessor macros are found inside the source code upon closer inspection. While these would mostly not be required for the program to be functional or even get compiled I use them because I can. Their names may or may not (they do) conflict with the language standard. _pure Usage The _pure macro is used to declare functions pure in a sense they shall always return the same value on the same input and never disturb state which is visible by other parts of the same program. The return value of these functions is always supposed to be used for something as that is their only option for output. Discarding their return value is equivalent of them not being called, and while compilers are not going to be aggressive enough to just optimize the function call away, they will warn if you waste resources, by calling these function without using their return value. Implementation If applicable this applies the C++17 [[nodiscard]] attribute, and iff using GCC or clang [[gnu::const]] . On a GCC compiler before C++11 this applies __attribute__((const)) . _retpure Usage The _retpure macro provides a weaker guarantee compared to the _pure macro in such a way it need not be deterministic. It's return value is pure so it doesn't write any other piece of memory, but it may return different values on sequential calls. It also suggests the requirement of use of the returned value, as that can be the sole reason for getting called since no other state changes in the program. The best example is a getter; chances are the return value is why the getter got called, yet if calling them in such a way the object's internal state changes they do not behave deterministically. See this example: #include iostream #define _retpure see actual code in utils.hpp ; class Foo { /// Interface public: _retpure int getBar() const { return bar; } void changeState() { bar += (bar + 1) * (bar + 1); } /// Fields private: int bar = 0; }; int main() { Foo foo; std::cout foo.getBar() std::endl; // 0 foo.changeState(); std::cout foo.getBar() std::endl; // 1 foo.changeState(); std::cout foo.getBar() std::endl; // 5 return 0; } The Foo#getBar() doesn't change any other value apart it's return, yet even calling it on the same thread is not guaranteed to return the same. Implementation If applicable this applies the C++17 [[nodiscard]] attribute, and iff using GCC or clang [[gnu::pure]] . On a GCC compiler before C++11 this applies __attribute__((pure)) . _retval Usage The _retval macro is not as radical as the _pure or _retpure but is on the same alignment. It means the returned value is most likely supposed to be used, however, the function itself is not _pure or even _retpure . Example is a member method which changes state in the object, yet returns some useful value. Most non-void functions that are not either _pure or _retpure are _retval . Implementation If using C++17 or greater [[nodiscard]] otherwise nothing. unless(x) if (!(x)) , no (diagnostic) explanation needed. until(x) while (!(x)) , no (diagnostic) explanation needed. Class declaration layout All classes try to follow the following convention of class layouts. Parts may be missing according to required usage of the class, for example a trivially constructable destructable classes may leave out the Contstructors destructor and Operators parts. class Name : public GreatClass, public virtual Abolishable { /// Interface public: /* Public and/or static methods */ /// Lifecycle public: Name() = default; Name(const Name cp) = default; Name(Name mv) noexcept = default; virtual ~Name() = default; /// Operators public: Name operator=(const Name cp) = default; Name operator=(Name mv) noexcept = default; /// Fields private: /* Fields */ /// Methods private: /* Internal methods */ }; Classes before this schema was finalized currently as InfoSoft CodeStyle C++ 2.1 , may not use any kind of noticeable schema, or use InfoSoft CodeStyle C++ 1.x . Differences to 1.x are: Fields are not denoted explicitly until 1.3 Fields are the first thing in the class in 1.x Until 1.2 different groups were created for static, public, inherited, implemented, etc methods Group names were using only two slashes and were put after the accesiblity modifier on the same line like so: public: // Implemented public methods Difference to 2.0 is: /// Lifecycle was /// Constructor(s?) ( destructor)? Transitioning old schemas into the new one is curently in","title":"Conventions"},{"location":"convention/#conventions","text":"The info::parse source uses some standard-ish conventions. These are not that intrusive after getting used them. The followings describe what these are and what they are doing, as some are a bit cryptic on first sight for those not necessarily well versed in the C++ language's abusability.","title":"Conventions"},{"location":"convention/#naming","text":"Variable names are camelCase Normal macros are SCREAMING_SNAKE_CASE Macros that are applied to something like a function are _lowercase Class names are PascalCase Classes that behave like interfaces are PascalCase and are an adjective, like the Java convention for interfaces. Member variables are _camelCase , while prefering single-word names, if possible, of course. Accessor member functions are the name of the member variable without the leading underscore Accessor member functions are the name of the member variable without the leading underscore, while taking a parameter of the approriate type static and/or non-member functions are PascalCase Namespace of the project is info::parse , implementation details inside the detail subnamespace.","title":"Naming"},{"location":"convention/#macros","text":"The following preprocessor macros are found inside the source code upon closer inspection. While these would mostly not be required for the program to be functional or even get compiled I use them because I can. Their names may or may not (they do) conflict with the language standard.","title":"Macros"},{"location":"convention/#_pure","text":"","title":"_pure"},{"location":"convention/#usage","text":"The _pure macro is used to declare functions pure in a sense they shall always return the same value on the same input and never disturb state which is visible by other parts of the same program. The return value of these functions is always supposed to be used for something as that is their only option for output. Discarding their return value is equivalent of them not being called, and while compilers are not going to be aggressive enough to just optimize the function call away, they will warn if you waste resources, by calling these function without using their return value.","title":"Usage"},{"location":"convention/#implementation","text":"If applicable this applies the C++17 [[nodiscard]] attribute, and iff using GCC or clang [[gnu::const]] . On a GCC compiler before C++11 this applies __attribute__((const)) .","title":"Implementation"},{"location":"convention/#_retpure","text":"","title":"_retpure"},{"location":"convention/#usage_1","text":"The _retpure macro provides a weaker guarantee compared to the _pure macro in such a way it need not be deterministic. It's return value is pure so it doesn't write any other piece of memory, but it may return different values on sequential calls. It also suggests the requirement of use of the returned value, as that can be the sole reason for getting called since no other state changes in the program. The best example is a getter; chances are the return value is why the getter got called, yet if calling them in such a way the object's internal state changes they do not behave deterministically. See this example: #include iostream #define _retpure see actual code in utils.hpp ; class Foo { /// Interface public: _retpure int getBar() const { return bar; } void changeState() { bar += (bar + 1) * (bar + 1); } /// Fields private: int bar = 0; }; int main() { Foo foo; std::cout foo.getBar() std::endl; // 0 foo.changeState(); std::cout foo.getBar() std::endl; // 1 foo.changeState(); std::cout foo.getBar() std::endl; // 5 return 0; } The Foo#getBar() doesn't change any other value apart it's return, yet even calling it on the same thread is not guaranteed to return the same.","title":"Usage"},{"location":"convention/#implementation_1","text":"If applicable this applies the C++17 [[nodiscard]] attribute, and iff using GCC or clang [[gnu::pure]] . On a GCC compiler before C++11 this applies __attribute__((pure)) .","title":"Implementation"},{"location":"convention/#_retval","text":"","title":"_retval"},{"location":"convention/#usage_2","text":"The _retval macro is not as radical as the _pure or _retpure but is on the same alignment. It means the returned value is most likely supposed to be used, however, the function itself is not _pure or even _retpure . Example is a member method which changes state in the object, yet returns some useful value. Most non-void functions that are not either _pure or _retpure are _retval .","title":"Usage"},{"location":"convention/#implementation_2","text":"If using C++17 or greater [[nodiscard]] otherwise nothing.","title":"Implementation"},{"location":"convention/#unlessx","text":"if (!(x)) , no (diagnostic) explanation needed.","title":"unless(x)"},{"location":"convention/#untilx","text":"while (!(x)) , no (diagnostic) explanation needed.","title":"until(x)"},{"location":"convention/#class-declaration-layout","text":"All classes try to follow the following convention of class layouts. Parts may be missing according to required usage of the class, for example a trivially constructable destructable classes may leave out the Contstructors destructor and Operators parts. class Name : public GreatClass, public virtual Abolishable { /// Interface public: /* Public and/or static methods */ /// Lifecycle public: Name() = default; Name(const Name cp) = default; Name(Name mv) noexcept = default; virtual ~Name() = default; /// Operators public: Name operator=(const Name cp) = default; Name operator=(Name mv) noexcept = default; /// Fields private: /* Fields */ /// Methods private: /* Internal methods */ }; Classes before this schema was finalized currently as InfoSoft CodeStyle C++ 2.1 , may not use any kind of noticeable schema, or use InfoSoft CodeStyle C++ 1.x . Differences to 1.x are: Fields are not denoted explicitly until 1.3 Fields are the first thing in the class in 1.x Until 1.2 different groups were created for static, public, inherited, implemented, etc methods Group names were using only two slashes and were put after the accesiblity modifier on the same line like so: public: // Implemented public methods Difference to 2.0 is: /// Lifecycle was /// Constructor(s?) ( destructor)? Transitioning old schemas into the new one is curently in","title":"Class declaration layout"},{"location":"installation/","text":"Installation If you wish to use InfoParse, logically, you need to acquire a copy of it. This is achievable in some ways, two of which are presented here. conan NOTE: The last released version is 1.5.2 . The advised way is now to use InfoCDepend . InfoParse uses conan as its dependency manager a packager. That means, we at InfoSoft gradually provide new InfoParse releases on our conan server, the latest of which is always recommended to be used. Our server is available at conan.isdevnet.com upon which InfoParse is published as InfoParse/2.0.1@bodand/stable . More in-depth documentation on using conan to get InfoParse follows for those not familiar with custom servers or with conan in general. [Note: We assume you already have a working copy of conan installed. To get conan look at their website for documentation.] Remote InfoSoft's conan package repository is conan.isdevnet.com . To tell conan to search in this repository in addition to conan-central one needs to add it as a remote: $ conan remote add InfoSoft-Conan-Server https://conan.isdevnet.com [Note: The InfoSoft-Conan-Server is the server's local name thus it can be any arbitrary locally unique string.] To see if it worked you can preform a listing on the current remotes and search for InfoParse and even list all packages on our server. $ conan remote list $ conan search InfoParse $ conan search -r InfoSoft-Conan-Server Requirement If you searched for InfoParse in the last paragraph you saw what is the name you need to add as a requirement. Add InfoParse/2.0.1@bodand/stable to your conanfile.(py|txt) and conan shall automagically install the package for you by running $ conan install . -if your_build_dir -b missing InfoCDepend InfoSoft's in-house project dependency installer CMake script is available at https://github.com/isbodand/InfoCDepend Using InfoCDepend you can locally install project dependencies for your projects: Get InfoCDepend The first step is to install the InfoCDepend script. Currently it does not, although future versions will update themselves so only one installation will be necessary. # InfoCDepend set(CDepend_FILE /home/travis/build/isbodand/infoparse/cmake/InfoCDepend.cmake ) file(DOWNLOAD https://raw.githubusercontent.com/isbodand/InfoCDepend/master/InfoCDepend.cmake ) include( ) Make sure the path you are downloading to exists. GetDependency After installing you local InfoCDepend script and included it, you can use it to get dependencies: # InfoParse GetDependency(InfoParse https://github.com/isbodand/infoparse.git) # other dependencies include_directories(libs/include) And that is it. You now have InfoParse installed locally. With tremendous additional logging information no-one asked for. Build it You can build and install it on your local machine as described in the appropriate documentation .","title":"Installation"},{"location":"installation/#installation","text":"If you wish to use InfoParse, logically, you need to acquire a copy of it. This is achievable in some ways, two of which are presented here.","title":"Installation"},{"location":"installation/#conan","text":"NOTE: The last released version is 1.5.2 . The advised way is now to use InfoCDepend . InfoParse uses conan as its dependency manager a packager. That means, we at InfoSoft gradually provide new InfoParse releases on our conan server, the latest of which is always recommended to be used. Our server is available at conan.isdevnet.com upon which InfoParse is published as InfoParse/2.0.1@bodand/stable . More in-depth documentation on using conan to get InfoParse follows for those not familiar with custom servers or with conan in general. [Note: We assume you already have a working copy of conan installed. To get conan look at their website for documentation.]","title":"conan"},{"location":"installation/#remote","text":"InfoSoft's conan package repository is conan.isdevnet.com . To tell conan to search in this repository in addition to conan-central one needs to add it as a remote: $ conan remote add InfoSoft-Conan-Server https://conan.isdevnet.com [Note: The InfoSoft-Conan-Server is the server's local name thus it can be any arbitrary locally unique string.] To see if it worked you can preform a listing on the current remotes and search for InfoParse and even list all packages on our server. $ conan remote list $ conan search InfoParse $ conan search -r InfoSoft-Conan-Server","title":"Remote"},{"location":"installation/#requirement","text":"If you searched for InfoParse in the last paragraph you saw what is the name you need to add as a requirement. Add InfoParse/2.0.1@bodand/stable to your conanfile.(py|txt) and conan shall automagically install the package for you by running $ conan install . -if your_build_dir -b missing","title":"Requirement"},{"location":"installation/#infocdepend","text":"InfoSoft's in-house project dependency installer CMake script is available at https://github.com/isbodand/InfoCDepend Using InfoCDepend you can locally install project dependencies for your projects:","title":"InfoCDepend"},{"location":"installation/#get-infocdepend","text":"The first step is to install the InfoCDepend script. Currently it does not, although future versions will update themselves so only one installation will be necessary. # InfoCDepend set(CDepend_FILE /home/travis/build/isbodand/infoparse/cmake/InfoCDepend.cmake ) file(DOWNLOAD https://raw.githubusercontent.com/isbodand/InfoCDepend/master/InfoCDepend.cmake ) include( ) Make sure the path you are downloading to exists.","title":"Get InfoCDepend"},{"location":"installation/#getdependency","text":"After installing you local InfoCDepend script and included it, you can use it to get dependencies: # InfoParse GetDependency(InfoParse https://github.com/isbodand/infoparse.git) # other dependencies include_directories(libs/include) And that is it. You now have InfoParse installed locally. With tremendous additional logging information no-one asked for.","title":"GetDependency"},{"location":"installation/#build-it","text":"You can build and install it on your local machine as described in the appropriate documentation .","title":"Build it"},{"location":"parsing/","text":"Parsing Rules Of course the most important factor of a parameter parser library is how it parses the parameters: which options are allowed?; does it support archaic stuff like the +name notation?; how customizable is it?; DOS-like /name support? This section defines how the currently, opposing my general ideology of the most general code being the best, quite python-y parsing engine works, which really needs heavy rework in regard to configuration the interface provides. (The answers to the above asked questions if you happen to suffer in notansweredquestionphobia: short POSIX -f and long parameters --facilitate-destruction-of-humanity ; No.; Not much.; No. - As you can see, quite a bad record.) Boolean Flags Boolean flags return either true or false. They do not take meaningful parameters, or the value they take is coerced into true or false according to a very perl-y truthyness table. They are initiated by creating an option with a non-nullptr bool pointer for the value spit back parameter. Raw flags As boolean flags are the easiest thing to parse, as they do (= should) not take a value to be parsed. As all options both have a short and a long name, flags do as well; -- flag and - f are parsed and the spit back value is a bool whether they were found in the input string or not. That's easy to reason about. This is where the shady parts come in. Negated flags All long flags are also possible to be parsed in their negated form, which is --no- flag . If this flag is found the option spits back a false value into the pointer. Each flag or parameter is only parsed once, unless specified otherwise, so the first flag wins and the others will be left there as is, since they were not to be removed by anything. Flags with values ?! Of course a library has to do something with high levels of bodandness to become an InfoSoft solution. So boolean can take values as described later and the parsed value is checked for truthyness according to the followings: 1) Literals: Yes True are true, No False are false. [Note: Literals are case insensitive.] 2) Numbers: True unless equals to zero. 0 is false, while -12, 69 and 420 are true. 3) Strings: True unless only consists of whitespace or is the empty string. \"\", \" \", \"\\n\\t\\n\" are false while \"a\", \"text text text\", \"bodand\" are true. Literals are tried first, if those do not match, then numbers are checked; if a string begins with at least one digit, atoi does its job on it and then numeric truthyness check if performed. So the string \"0text\" is false however true it is according to stringic (?) truthyness. A good example for this behaviour, invocation-wise, is using this in a shell script for optional flags without needing branching. which wget 2 /dev/null This snipped prints the path at which wget is found or the empty string. Using this as a parameter for a flag can make an optional parameter if wget is found. ./prog --use-wget=$(which wget 2 /dev/null) This will set --use-wget is wget was found, and to false otherwise. Value taking options There exist, of course, values whose job is to take actual meaningful parameters and pass them into the program. These values compared to the values taken by boolean flags do actually show up in the library's caller program, unless, of course, an option is defined to dump into nullptr . Direct value Options take the value that immediately succeed them, so care must be taken when deciding which option to add before the other. For example: Our options are --text and --text-overlay . If --text is registered first --text-overlay will never match: Params - text text text --text-overlay=Cocaine text text --text matches there ^^^^^^ --text will use the value ^^^^^^^^^^^^^^^^ However, if --text-overlay was registered first, the wanted behavior would happen, and --text-overlay would be set to Cocaine . The value absorbed equals to the value split up by the local shell, so if using quotes or apostrophes, then spaces are viable, otherwise the value spans to the next whitespace character, or the end of string. Optional space Compared to the quite barbaric looking way of gluing together the option and its value, a more aesthetic way of doing things is by splitting them up with a space. This space when parsing happens is disregarded and the value is taken as if the flags name were to include that space. So --textAbsorption and --text Absorption are equal. Assignments Assignments look cool, so they are regarded as the most important part of parameter parsing and using options with in InfoParse. Compared to this rich (although confusing at first) behavior presented no other implementation offers such freedom of supplying parameters. Equals sign This is the common behavior on most programs thus the common notation is bestowed to it: -- option = val , without allowing spaces before the val . Short options allow for this as well, in the form of - short = val . After finding an option's name; if the following character is an equals sign, the following are parsed as a value for the flag until the next space. This means -- option = parses the value as the empty string. Colon While having an equals sign or a colon might seem like a trivial difference for InfoParse it is not. While an equals sign is lazy to do any more work than necessary, the colon searches for the match with her extreme energy reserves, and disregards the amount of whitespace between her and her prey. The parser after finding an option's name followed by a colon (':'), seeks out the first non-whitespace character then the next whitespace character, between those is the value to use for whatever. [Note: The colon can still return the empty string if she is at the end of the string as there is hardly anything to seek. The idea that is should loop around was discarded for it would be too confusing] The differences are presented here: text --wordval? - val? text (1) text --word val? - val? text text --word=val? - val? text text --word= val? - text val? text --word= - text text --word:val? - val? text text --word: val? - val? text text --word: - text [Note: Boolean flags do not take the value that directly follows them so (1) is not legal if --word takes a boolean.]","title":"Parsing rules"},{"location":"parsing/#parsing-rules","text":"Of course the most important factor of a parameter parser library is how it parses the parameters: which options are allowed?; does it support archaic stuff like the +name notation?; how customizable is it?; DOS-like /name support? This section defines how the currently, opposing my general ideology of the most general code being the best, quite python-y parsing engine works, which really needs heavy rework in regard to configuration the interface provides. (The answers to the above asked questions if you happen to suffer in notansweredquestionphobia: short POSIX -f and long parameters --facilitate-destruction-of-humanity ; No.; Not much.; No. - As you can see, quite a bad record.)","title":"Parsing Rules"},{"location":"parsing/#boolean-flags","text":"Boolean flags return either true or false. They do not take meaningful parameters, or the value they take is coerced into true or false according to a very perl-y truthyness table. They are initiated by creating an option with a non-nullptr bool pointer for the value spit back parameter.","title":"Boolean Flags"},{"location":"parsing/#raw-flags","text":"As boolean flags are the easiest thing to parse, as they do (= should) not take a value to be parsed. As all options both have a short and a long name, flags do as well; -- flag and - f are parsed and the spit back value is a bool whether they were found in the input string or not. That's easy to reason about. This is where the shady parts come in.","title":"Raw flags"},{"location":"parsing/#negated-flags","text":"All long flags are also possible to be parsed in their negated form, which is --no- flag . If this flag is found the option spits back a false value into the pointer. Each flag or parameter is only parsed once, unless specified otherwise, so the first flag wins and the others will be left there as is, since they were not to be removed by anything.","title":"Negated flags"},{"location":"parsing/#flags-with-values","text":"Of course a library has to do something with high levels of bodandness to become an InfoSoft solution. So boolean can take values as described later and the parsed value is checked for truthyness according to the followings: 1) Literals: Yes True are true, No False are false. [Note: Literals are case insensitive.] 2) Numbers: True unless equals to zero. 0 is false, while -12, 69 and 420 are true. 3) Strings: True unless only consists of whitespace or is the empty string. \"\", \" \", \"\\n\\t\\n\" are false while \"a\", \"text text text\", \"bodand\" are true. Literals are tried first, if those do not match, then numbers are checked; if a string begins with at least one digit, atoi does its job on it and then numeric truthyness check if performed. So the string \"0text\" is false however true it is according to stringic (?) truthyness. A good example for this behaviour, invocation-wise, is using this in a shell script for optional flags without needing branching. which wget 2 /dev/null This snipped prints the path at which wget is found or the empty string. Using this as a parameter for a flag can make an optional parameter if wget is found. ./prog --use-wget=$(which wget 2 /dev/null) This will set --use-wget is wget was found, and to false otherwise.","title":"Flags with values ?!"},{"location":"parsing/#value-taking-options","text":"There exist, of course, values whose job is to take actual meaningful parameters and pass them into the program. These values compared to the values taken by boolean flags do actually show up in the library's caller program, unless, of course, an option is defined to dump into nullptr .","title":"Value taking options"},{"location":"parsing/#direct-value","text":"Options take the value that immediately succeed them, so care must be taken when deciding which option to add before the other. For example: Our options are --text and --text-overlay . If --text is registered first --text-overlay will never match: Params - text text text --text-overlay=Cocaine text text --text matches there ^^^^^^ --text will use the value ^^^^^^^^^^^^^^^^ However, if --text-overlay was registered first, the wanted behavior would happen, and --text-overlay would be set to Cocaine . The value absorbed equals to the value split up by the local shell, so if using quotes or apostrophes, then spaces are viable, otherwise the value spans to the next whitespace character, or the end of string.","title":"Direct value"},{"location":"parsing/#optional-space","text":"Compared to the quite barbaric looking way of gluing together the option and its value, a more aesthetic way of doing things is by splitting them up with a space. This space when parsing happens is disregarded and the value is taken as if the flags name were to include that space. So --textAbsorption and --text Absorption are equal.","title":"Optional space"},{"location":"parsing/#assignments","text":"Assignments look cool, so they are regarded as the most important part of parameter parsing and using options with in InfoParse. Compared to this rich (although confusing at first) behavior presented no other implementation offers such freedom of supplying parameters.","title":"Assignments"},{"location":"parsing/#equals-sign","text":"This is the common behavior on most programs thus the common notation is bestowed to it: -- option = val , without allowing spaces before the val . Short options allow for this as well, in the form of - short = val . After finding an option's name; if the following character is an equals sign, the following are parsed as a value for the flag until the next space. This means -- option = parses the value as the empty string.","title":"Equals sign"},{"location":"parsing/#colon","text":"While having an equals sign or a colon might seem like a trivial difference for InfoParse it is not. While an equals sign is lazy to do any more work than necessary, the colon searches for the match with her extreme energy reserves, and disregards the amount of whitespace between her and her prey. The parser after finding an option's name followed by a colon (':'), seeks out the first non-whitespace character then the next whitespace character, between those is the value to use for whatever. [Note: The colon can still return the empty string if she is at the end of the string as there is hardly anything to seek. The idea that is should loop around was discarded for it would be too confusing] The differences are presented here: text --wordval? - val? text (1) text --word val? - val? text text --word=val? - val? text text --word= val? - text val? text --word= - text text --word:val? - val? text text --word: val? - val? text text --word: - text [Note: Boolean flags do not take the value that directly follows them so (1) is not legal if --word takes a boolean.]","title":"Colon"}]}